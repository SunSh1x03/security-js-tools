<script src="https://unpkg.com/vis-network/dist/vis-network.min.js"></script>
<script>
  // Ajuste para sua API (editar se mudar)
  const API_BASE = "https://php-sectools.onrender.com";

  async function loadGraph(id){
    const url = `${API_BASE}/api/graph?id=${encodeURIComponent(id)}`;
    const resp = await fetch(url, { credentials: 'omit' });
    // Expõe status para debug
    if(!resp.ok){
      const text = await resp.text().catch(()=>'<no body>');
      throw new Error(`HTTP ${resp.status}: ${text}`);
    }
    // tenta parse JSON
    let data;
    try { data = await resp.json(); }
    catch(e){ throw new Error('Resposta não é JSON: ' + e.message); }

    return data;
  }

  // Normaliza vários formatos possíveis para { nodes:[], edges:[] }
  function normalizeGraphData(data){
    if(!data) return {nodes:[], edges:[]};

    // se já está no formato esperado
    if(Array.isArray(data.nodes) && Array.isArray(data.edges)) return { nodes: data.nodes, edges: data.edges };

    // se veio dentro de um objeto graph: { graph: { nodes, edges } }
    if(data.graph && Array.isArray(data.graph.nodes) && Array.isArray(data.graph.edges)) {
      return { nodes: data.graph.nodes, edges: data.graph.edges };
    }

    // se veio num wrapper comum { result: {...} } ou similar
    if(data.result && Array.isArray(data.result.nodes) && Array.isArray(data.result.edges)) {
      return { nodes: data.result.nodes, edges: data.result.edges };
    }

    // se veio apenas nodes ou apenas edges
    const nodes = Array.isArray(data.nodes) ? data.nodes : (Array.isArray(data.graph?.nodes) ? data.graph.nodes : []);
    const edges = Array.isArray(data.edges) ? data.edges : (Array.isArray(data.graph?.edges) ? data.graph.edges : []);

    return { nodes, edges };
  }

  function renderGraph(data){
    const container = document.getElementById('network');
    const dsNodes = new vis.DataSet((data.nodes || []).map(n => {
      // assegura que cada node tem id e label
      return { id: n.id ?? n.ip ?? n.name ?? Math.random().toString(36).slice(2,9), label: n.label ?? n.name ?? n.hostname ?? n.ip ?? String(n.id) , group: n.group ?? n.type ?? 'host', title: JSON.stringify(n.meta ?? n, null, 2) };
    }));
    const dsEdges = new vis.DataSet((data.edges || []).map(e => {
      return { from: e.from, to: e.to, label: e.label ?? e.relation ?? '', arrows: e.arrows ?? 'to' };
    }));

    const options = {
      groups: {
        host: { shape: 'dot', size:18 },
        service: { shape: 'box' },
        vuln: { shape: 'triangle' }
      },
      interaction: { hover:true, tooltipDelay:100 },
      physics: { stabilization: true }
    };
    if(container._visNetwork) container._visNetwork.destroy();
    container._visNetwork = new vis.Network(container, { nodes: dsNodes, edges: dsEdges }, options);
  }

  // UI helpers
  function setStatus(msg){ document.getElementById('status').textContent = msg; }
  function showRaw(obj){ const raw = document.getElementById('raw'); raw.textContent = JSON.stringify(obj, null, 2); raw.style.display = 'block'; }

  document.getElementById('btnLoad').addEventListener('click', async ()=>{
    const id = document.getElementById('graphId').value || '1';
    setStatus('Carregando...');
    document.getElementById('raw').style.display = 'none';
    try {
      const resp = await loadGraph(id);
      // mostra a resposta crua para debug
      showRaw(resp);

      // normaliza
      const normalized = normalizeGraphData(resp);

      if(!normalized.nodes.length && !normalized.edges.length){
        setStatus('Nenhum nó/edge encontrado para esse graph id.');
        return;
      }

      renderGraph(normalized);
      setStatus('OK');
    } catch (e){
      console.error(e);
      setStatus('Erro: ' + e.message);
    }
  });

  // Try default graph=1 on load
  (async ()=>{
    document.getElementById('graphId').value = '1';
    document.getElementById('btnLoad').click();
  })();
</script>
